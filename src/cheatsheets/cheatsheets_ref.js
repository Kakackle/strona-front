/**
 * @file cheatsheets_ref.js - main js file of the cheatshets subpage
 * @author MM
 * @see <a href="https://google.com"> Google </a>
 */

// elementy programu:
// 1. przechowywanie db linkow w postaci tabeli i w localstorage
// 2. tworzenie elementow DOM na podstawie tabeli
// 3. filtracja tablic przed renderem
// 4. obsluga zdarzen dodawania, usuwania, edycji linkow/obiektow

// TODO: sortowanie, po dacie, kliknieciach to tam jebac
// TODO: upiekszenie, bo teraz wyglada bardzo roboczo, nie chcialbym korzystac z tego, zbyt malo przejrzyste, zbite
// TODO: paginacja, mam funkcje render, moze moge podzielic tablice i wywolywac funckje z podawaniem jej czesci
// TODO: dodawanie z pliku json bezposrednio a nie przez tekst?

/**
 * Arrays of cheatsheet objects - See {@tutorial general-tutorial}
 * @type {Array}
 */
let cheatsheets = []; //tablica linkow w systemie
let tags = []; //tablica tagow
let appliedTags = []; //tagi do filtracji

//------------- elementy DOM -------------
//localStorage
const clearButton = document.querySelector(".clear-button");
const exampleButton = document.querySelector(".example-button");
const debugButton = document.querySelector(".debug-button");

//otworz sekcje dodawania linkow
const add_new_link = document.querySelector(".add-section-title");
const add_json = document.querySelector(".json-title");
//dropdown obszar wpisywania danych linkow
const add_dropdown = document.querySelector(".add-drop");
const add_json_dropdown = document.querySelector(".add-drop-json");
const title_input = document.querySelector(".add-title");
const link_input = document.querySelector(".add-link");
const tag1_input = document.querySelector(".add-tag1");
const tag2_input = document.querySelector(".add-tag2");
const tag3_input = document.querySelector(".add-tag3");
const favCheckbox = document.querySelector(".add-fav-check");
const json_text_input = document.querySelector(".json-text");
//submit dodawania
const link_submit_button = document.querySelector(".submit-link");
const submit_json = document.querySelector(".submit-json");
const close_dropdown = document.querySelector(".close-drop");
const close_drop_json = document.querySelector(".close-drop-json");

//obszary do renderowania
const fav_area = document.querySelector(".fav-area");
const most_links = document.querySelector(".most-links");
const all_links = document.querySelector(".all-links");

//wszystkie linki - do obslugi eventow na kliknieciu ich w dowolnym miejscu na stronie
let all_link_elements = [];
//obszar tagow
const type_tags = document.querySelector(".type-tags");
let tag_checkboxes = document.querySelectorAll(".tag-checkbox-box");
const filterButton = document.querySelector(".filter-button");

//searchbar
const fav_search = document.querySelector(".fav-search");

/**
 * Cheatsheet object
 * @typedef {Object} Cheat
 * @property {string} title - link title text
 * @property {string} link - link text
 * @property {Array<string>} tags - array of tags
 * @property {string} date - autogenerated date of creation
 * @property {string} dateLast - auto date of last interaction
 * @property {boolean} isFav - is link added to favs
 */
// ------------ 1. Obsluga dodawania i usuwania ----------

//tworzenie i zwracanie obiektu cheatsheetu
/**
 *
 * @param {string} title - the title of the link
 * @param {string} link - hyperlink in string format
 * @param {Array<string>} tags - array of 3 string values with link tags
 * @param {boolean} isFav - will link be added to favourites
 * @returns {Cheat} cheatsheet object with title, link, tags, date, dateLast, clicks and isFav fields
 */
const createNewCheatsheet = function (title, link, tags, isFav) {
  const date = new Date();
  /**
   * @type {Cheat}
   */
  const cheat = {
    title: title,
    link: link,
    tags: tags,
    date: `${date.getDate()}:${date.getMonth() + 1}:${date.getFullYear()}`,
    dateLast: `${date.getDate()}:${date.getMonth() + 1}:${date.getFullYear()}`,
    clicks: 0,
    isFav: isFav,
  };
  return cheat;
};

//zapisz podana liste wraz z nazwa do localstorage
const saveToLocalStorage = function (arr, arr_name) {
  localStorage.setItem(`${arr_name}`, JSON.stringify(arr));
};

// czyszczenie localstorage
const clearStorage = function () {
  localStorage.clear();
};

const getFromLocal = function () {
  const localCheatsheets = JSON.parse(localStorage.getItem("cheatsheets"));
  if (localCheatsheets) cheatsheets = localCheatsheets;
  else cheatsheets = [];
  const localTags = JSON.parse(localStorage.getItem("tags"));
  if (localTags) tags = localTags;
  else tags = [];
};

//czyszczenie linkow i tagow
const clearObjects = function () {
  cheatsheets = [];
  tags = [];
};

//--------- obsluga dodania/usuwania elementow tablic --------

const deleteEntry = function (e) {
  const counterIndex =
    e.target.parentNode.querySelector(".counter-el").innerHTML;
  cheatsheets.splice(counterIndex, 1);
  callCreationFunctions(cheatsheets);
};

//dodanie od fav poprzez zmienienie isFav, czyli aktualizacje obiektu z cheatsheets
//i tak samo usuniecie, przy czym usuniecie tylko na przycisku w sekcji fav, dodanie w listach
const removeFav = function (e) {
  const counterIndex =
    e.target.parentNode.querySelector(".counter-el").innerHTML;
  cheatsheets[counterIndex].isFav = false;
  renderFavLinksEntries(cheatsheets);
};
const addFav = function (e) {
  const counterIndex =
    e.target.parentNode.parentNode.querySelector(".counter-el").innerHTML;
  cheatsheets[counterIndex].isFav = true;
  renderFavLinksEntries(cheatsheets);
  createEventListeners();
  saveToLocalStorage(cheatsheets, "cheatsheets");
};

//// zebranie istniejacych tagow, moze powinno byc wywolywane przy dodawaniu
const gatherTags = function () {
  cheatsheets.forEach((cheat) => {
    cheat.tags.forEach((tag) => {
      if (!tags.includes(tag)) tags.push(tag);
    });
  });
  saveToLocalStorage(tags, "tags");
};

// --------- 2. render elementow tabel ---------

//tabela linkow wszystkich template

const renderListEntries = function (renderList, list_container) {
  list_container.innerHTML = ``;
  renderList.forEach((cheat) => {
    const cont_li = document.createElement("li");
    cont_li.innerHTML = `
    <div class="li-div">
    <p data-count="${renderList.indexOf(cheat)}"
    class="hidden counter-el">${renderList.indexOf(cheat)}</p>
    <p class="list-title">
    <a
      class="link-copy most-div-head-long"
      href="${cheat.link}"
      target="_blank"
      rel="noopener noreferrer"
      >${cheat.title}</a
    >
    </p>
    <div class="most-link-tags most-link-short">
      <span>${cheat.tags[0]}</span>
      <span>${cheat.tags[1]}</span>
      <span>${cheat.tags[2]}</span>
    </div>
    <p class="click-counter">${cheat.clicks} cl.</p>
    <p>${cheat.date}</p>
    <p>${cheat.dateLast}</p>
    <ion-icon class="most-delete md hydrated" name="trash-bin" role="img" aria-label="trash bin"></ion-icon>
    <ion-icon class="most-addfav md hydrated" name="star" role="img" aria-label="checkmark"></ion-icon>
    </div>
    `;
    list_container.appendChild(cont_li);
  });
};

//FIXME: sortowanie po najbardziej klikanych i render tylko pierwszych 20?
const renderMostClicked = function (renderList) {
  let mostList = [];
  mostList = renderList.toSorted((a, b) => {
    if (a.clicks > b.clicks) return -1; //a bedzie przed b
    if (a.clicks < b.clicks) return 1;
    return 0;
  });
  if (mostList.length < 3) renderListEntries(mostList, most_links);
  else renderListEntries(mostList.slice(0, 3), most_links);
};

const renderFavLinksEntries = function (renderList) {
  //reset do stanu poczatkowego z predefiniowanym elementem na czas testow
  fav_area.innerHTML = ``;
  const favCheatsheets = renderList.filter((cheat) => cheat.isFav === true);
  favCheatsheets.forEach((cheat) => {
    const fav_div = document.createElement("div");
    fav_div.classList.add("fav"); //klasa glowna
    // cheat.tags.forEach((tag) => fav_div.classList.add(`${tag}`)); //klasy tagow
    //pierwszy tag jako definujacy wyglad?
    fav_div.classList.add(`${cheat.tags[0]}-border`);
    fav_div.innerHTML = `
    <p data-count="${renderList.indexOf(cheat)}"
    class="hidden counter-el">${renderList.indexOf(cheat)}</p>
    <p class="fav-title">${cheat.title}</p>
      <p class="fav-link">
        <a
          class="link-copy"
          href="${cheat.link}"
          target="_blank"
          rel="noopener noreferrer"
          >${cheat.link}</a
        >
      </p>
      <div class="fav-applied-tags">
        <span class="fav-tag ${cheat.tags[0]}"> ${cheat.tags[0]} </span>
        <span class="fav-tag ${cheat.tags[1]}"> ${cheat.tags[1]} </span>
        <span class="fav-tag ${cheat.tags[2]}"> ${cheat.tags[2]} </span>
      </div>
      <span class="fav-date">${cheat.date}</span>
      <span class="fav-clicks click-counter">${cheat.clicks} cl.</span>
      <ion-icon class="fav-icon fav-delete" name="trash-bin"></ion-icon>
      <ion-icon class="fav-icon fav-remove" name="close"></ion-icon>`;
    fav_area.appendChild(fav_div);
  });
};

const renderTags = function () {
  gatherTags();
  type_tags.innerHTML = `<p class="tag-sect-title">Link type:</p>`;
  tags.forEach((tag) => {
    const tag_checkbox = document.createElement("div");
    tag_checkbox.classList.add("tag-checkbox");
    tag_checkbox.innerHTML = `<input
    class="tag-checkbox-box"
    type="checkbox"
    id="${tag}"
    name="${tag}"
    value="${tag}"
  />
  <label class="tag-checkbox" for="${tag}"> ${tag} </label>
    `;
    type_tags.appendChild(tag_checkbox);
  });
  //aktualizacja tag checkboxes
  tag_checkboxes = document.querySelectorAll(".tag-checkbox-box");
};

//create event listeners on links in tables
const createEventListeners = function () {
  const mostDeleteList = document.querySelectorAll(".most-delete");
  mostDeleteList.forEach((most_delete) => {
    most_delete.addEventListener("click", (e) => {
      deleteEntry(e);
    });
  });
  const mostAddFavList = document.querySelectorAll(".most-addfav");
  mostAddFavList.forEach((most_addfav) => {
    most_addfav.addEventListener("click", (e) => {
      addFav(e);
    });
  });
  const favDeleteList = document.querySelectorAll(".fav-delete");
  favDeleteList.forEach((fav_delete) => {
    fav_delete.addEventListener("click", (e) => {
      deleteEntry(e);
    });
  });
  const favRemoveList = document.querySelectorAll(".fav-remove");
  favRemoveList.forEach((fav_remove) => {
    fav_remove.addEventListener("click", (e) => {
      removeFav(e);
    });
  });
  collectLinks();
  all_link_elements.forEach((link_elem) => {
    link_elem.addEventListener("click", (e) => {
      e.stopPropagation();
      countClick(e);
      renderMostClicked(cheatsheets);
    });
  });
  addEditEvents();
};

//render wszystkich grup obiektow na stronie
const renderWebsite = function (renderList) {
  renderFavLinksEntries(renderList);
  renderListEntries(renderList, all_links);
  // renderListEntries(renderList, most_links);
  renderMostClicked(renderList);
  renderTags();
};

//reset inputow dodawania
const resetAddInputs = function () {
  title_input.value = "";
  link_input.value = "";
  tag1_input.value = "";
  tag2_input.value = "";
  tag3_input.value = "";
};

// collect all link elements for event listeners
const collectLinks = function () {
  // let fav_links = document.querySelectorAll(".fav-link");
  // let table_links = document.querySelectorAll(".link-copy");
  // all_link_elements = fav_links.concat(table_links);
  all_link_elements = document.querySelectorAll(".fav-link, .link-copy");
};

//zliczanie klikniecia i aktualizacja tekstu
const countClick = function (e) {
  //selekcja obiektu
  const counterIndex =
    e.target.parentNode.parentNode.querySelector(".counter-el").innerHTML;
  cheatsheets[counterIndex].clicks += 1;
  //wszystkie wystapienia
  const elems = collectByCounter(counterIndex);
  //aktualizacja tekstu
  elems.forEach((el) => {
    el.parentNode.querySelector(
      ".click-counter"
    ).textContent = `${cheatsheets[counterIndex].clicks} cl.`;
  });
  saveToLocalStorage(cheatsheets, "cheatsheets");
};

//collect and actualize all fav-clicks elements by data value
const collectByCounter = function (count) {
  const elems = document.querySelectorAll(`[data-count="${count}"]`);
  return elems;
};

//#region
/* -------------------------------------------------------------------------- */
/*                     obsluga edycji elementow na stronie                    */
/* -------------------------------------------------------------------------- */

//wybor wszystkich elementow tytulu
const getTitleElements = function () {
  const title_els = document.querySelectorAll(".fav-title, .list-title a");
  return title_els;
};
//wybor wszystkich tagow
const getTagElements = function () {
  const tag_els = document.querySelectorAll(
    ".most-link-tags span, .fav-applied-tags span"
  );
  return tag_els;
};

//selekcja elementu z counterem na podstawie tytulu
const selectCounterByTitle = function (title_el) {
  const counterEl = title_el.parentNode.querySelector(".counter-el");
  //const counterIndex = counterEl.dataset.count;
  const counterIndex = counterEl.innerHTML;
  return counterIndex;
};
//selekcja elementu z counterem na podstawie tagu
const selectCounterByTag = function (title_el) {
  const counterEl = title_el.parentNode.parentNode.querySelector(".counter-el");
  //const counterIndex = counterEl.dataset.count;
  const counterIndex = counterEl.innerHTML;
  return counterIndex;
};

//FIXME: niestety przewidziany problem pojawil sie - w listach najpierw obsluguje click, potem
// dblclick, wiec trzeba bedzie dodac kolejny element po prostu zamiast a, ale mi sie nie chce tbh ahhh
//umozliw edycje i na podstawie countera elementu zapisz to do bazy danych
// funkcja do dodania do ustawiania event listenerow
const addEditEvents = function () {
  const title_elems = getTitleElements();
  const tag_elems = getTagElements();
  //dodanie obu eventow - na dblclick umozliw edycje, na wyjscie wylacz i zapisz zmiany
  title_elems.forEach((title) => {
    //event start edycji
    title.addEventListener("dblclick", (e) => {
      e.preventDefault();
      e.target.setAttribute("contenteditable", "true");
    });
    //event koniec edycji
    title.addEventListener("mouseleave", (e) => {
      e.preventDefault();
      //prewencja odpalania eventu za kazdym razem jak myszka wyjdzie, tylko po edycji\
      if (title.getAttribute("contenteditable") === "true") {
        title.setAttribute("contenteditable", "false");
        const newTitle = title.innerHTML;
        const countIndex = selectCounterByTitle(title);
        cheatsheets[countIndex].title = newTitle;
        callCreationFunctions(cheatsheets);
      }
    });
  });
  //
  tag_elems.forEach((tag) => {
    let newTag = "";
    let oldTag = "";
    //event start edycji
    tag.addEventListener("dblclick", (e) => {
      e.preventDefault();
      oldTag = e.target.textContent.trim();
      e.target.setAttribute("contenteditable", "true");
    });
    //event koniec edycji
    tag.addEventListener("mouseleave", (e) => {
      e.preventDefault();
      //prewencja odpalania eventu za kazdym razem jak myszka wyjdzie, tylko po edycji\
      if (tag.getAttribute("contenteditable") === "true") {
        tag.setAttribute("contenteditable", "false");
        newTag = tag.textContent.trim();
        const countIndex = selectCounterByTag(tag);
        cheatsheets[countIndex].tags.forEach((el_tag) => {
          if (el_tag === oldTag) {
            // el_tag = newTag;
            cheatsheets[countIndex].tags[
              cheatsheets[countIndex].tags.indexOf(el_tag)
            ] = newTag;
          }
        });
        callCreationFunctions(cheatsheets);
      }
    });
  });
};

//#endregion

// ----------- filtracja -------------
// aplikacja filtrow z tagow

const filterByTags = function () {
  appliedTags = [];
  tag_checkboxes.forEach((tag) => {
    if (tag.checked) appliedTags.push(tag.value);
  });
  let renderList = [];
  if (appliedTags.length === 0) {
    renderList = cheatsheets;
  } else {
    renderList = cheatsheets.filter(
      (cheat) =>
        appliedTags.includes(cheat.tags[0]) ||
        appliedTags.includes(cheat.tags[1]) ||
        appliedTags.includes(cheat.tags[2])
    );
  }
  console.log(renderList);
  return renderList;
};

const filterBySearch = function () {
  let searchterm = fav_search.value;
  console.log(searchterm);
  let renderList = [];
  //sprawdzanie po skladowych tagow
  let includesTag = 0;
  cheatsheets.forEach((cheat) => {
    cheat.tags.forEach((tag) => {
      if (tag.includes(searchterm)) {
        includesTag = 1;
        console.log(`${cheat.title} : ${includesTag}`);
      }
    });
  });
  //sprawdzanie czy zawiera tag w calosci
  // cheat.tags.includes(searchterm)

  renderList = cheatsheets.filter(
    (cheat) =>
      cheat.title.includes(searchterm) ||
      cheat.link.includes(searchterm) ||
      includesTag
  );
  return renderList;
};

// ------------ 4. EventListeners ----------

//obsluga widocznosci menu dodawania linkow
add_new_link.addEventListener("click", (e) => {
  e.preventDefault();
  add_dropdown.style.display = "flex";
});

close_dropdown.addEventListener("click", (e) => {
  e.preventDefault();
  add_dropdown.style.display = "none";
});

add_json.addEventListener("click", (e) => {
  e.preventDefault();
  add_json_dropdown.style.display = "flex";
});

close_drop_json.addEventListener("click", (e) => {
  e.preventDefault();
  add_json_dropdown.style.display = "none";
});

//tworzenie nowych elementow z wypelnionych pol
link_submit_button.addEventListener("click", (e) => {
  const cheat = createNewCheatsheet(
    title_input.value,
    link_input.value,
    [tag1_input.value, tag2_input.value, tag3_input.value],
    favCheckbox.checked
  );
  resetAddInputs();
  cheatsheets.push(cheat);
  //dodawanie tagow przy tworzeniu
  cheat.tags.forEach((tag) => {
    if (!tags.includes(tag)) tags.push(tag);
  });
  callCreationFunctions(cheatsheets);
});

const getJsonInput = function () {
  //parse wartosci z pola
  //stworzenie nowych obiektow moze wykorzystujac createnewcheatsheet?
  //zapisywanie tych obiektow do tablicy
  //na koniec do localstorage i render
  //--- kwestie: ---
  //przy czym uzytnik nie podaje wszystkich informacji w tekscie
  //wiec najlepiej wykorzystac gotowa funkcje create
  //a tekst wpakowac w nowy obiekt, a wlasciwie tablice obiektow
  //i potem foreach i wyciagac z niej i wpakowywac w funkcje create
  let json_text = JSON.parse(json_text_input.value);
  json_text.forEach((item) => {
    const cheat = createNewCheatsheet(
      item.title,
      item.link,
      [item.tag1, item.tag2, item.tag3],
      item.isFav === "true"
    );
    cheatsheets.push(cheat);
    cheat.tags.forEach((tag) => {
      if (!tags.includes(tag)) tags.push(tag);
    });
  });
  callCreationFunctions(cheatsheets);
};

submit_json.addEventListener("click", (e) => {
  getJsonInput();
});

//filtracja
fav_search.addEventListener("input", (e) => {
  e.preventDefault();
  callCreationFunctions(filterBySearch());
});

filterButton.addEventListener("click", (e) => {
  e.preventDefault();
  // callCreationFunctions(filterByTags());
  const renderList = filterByTags();
  renderFavLinksEntries(renderList);
  renderListEntries(renderList, all_links);
  // renderListEntries(renderList, most_links);
  renderMostClicked(renderList);
});

clearButton.addEventListener("click", (e) => {
  e.preventDefault();
  clearStorage(); //czysci pamiec
  getFromLocal(); //aktualizuje wewnetrzne dane
  renderWebsite(cheatsheets); //renderuje strone
  collectLinks();
});

exampleButton.addEventListener("click", (e) => {
  addTestObjects();
});

debugButton.addEventListener("click", (e) => {
  debugFunction();
});

//funkcja zbierajaca funkcje zwiazane z tworzeniem nowych cheatsheetow, bo powtarzaja sie
const callCreationFunctions = function (renderList) {
  saveToLocalStorage(cheatsheets, "cheatsheets");
  saveToLocalStorage(tags, "tags");
  renderWebsite(renderList);
  createEventListeners();
  collectLinks();
};

// ---------- call at load -------------
const mainFunc = function () {
  console.log(tags);
  getFromLocal();
  console.log(tags);
  renderWebsite(cheatsheets);
  createEventListeners();
};

mainFunc();

// ---------- tests -----------
// predefiniowany obiekt do testow
const addTestObjects = function () {
  const cheat1 = createNewCheatsheet(
    "10 ways to hide elements in CSS",
    "https://www.sitepoint.com/hide-elements-in-css/",
    ["prog", "css", "howto"],
    true
  );
  const cheat2 = createNewCheatsheet(
    "Curated CSS gradients",
    "https://gradients.shecodes.io/ ",
    ["prog", "css", "resources"],
    false
  );
  cheatsheets.push(cheat1);
  cheatsheets.push(cheat2);
  callCreationFunctions(cheatsheets);
};

const debugFunction = function () {
  console.log(`------- new debug -------`);
  const countElems = document.querySelectorAll(".counter-el");
  countElems.forEach((count) => {
    const countIndex = count.innerHTML;
    console.log(
      `cheatsheets:`,
      "\n",
      `${countIndex}: ${JSON.stringify(cheatsheets[countIndex])}`
    );
  });
};
